Jack: Rack for JavaScript

	echo "Rack provides an minimal interface between webservers supporting Ruby and Ruby frameworks" | sed -e s/Rack/Jack/g -e s/Ruby/JavaScript/g

	Indeed, Jack is a fairly straightforward port of Rack (http://rack.rubyforge.org/) to JavaScript, with adjustments where necessary. Of course it is meant for use on the server rather than in the browser.
	
	It provides a common interface between web servers and web applications or frameworks written in JavaScript.

    Homepage: http://jackjs.org/

    Source & Download: http://github.com/tlrobinson/jack/

    Mailing list: http://groups.google.com/group/jack-js
    
    IRC: #jack-js on irc.freenode.net
    

== Getting Started:

	Jack currently supports the Jetty (and other servlet containers) and Simple webservers using Rhino, and it should be easy to integrate with other JavaScript interpreters and web servers.

    To start working with Jack, ensure you have the Rhino (js.jar) and Jetty ("jetty", "jetty-util", "servlet-api") or Simple ("simple") jars in your CLASSPATH environment variable. From the root of the project, run "bin/jackup", which will start a sample application at localhost:8080:

		./bin/jackup
	

== Writing Jack Applications:
		
	A Rack application is simply a JavaScript object that responds to the "invoke" method. It should return an array containing three elements: the status code (an integer), the headers values (a hash), and a body object (anything that responds to the "each" method).
	
	We have extended JavaScript Function objects to respond to "invoke" (it just calls itself, so any function is a valid Rack application, provided it returns the right types), and JavaScript Array and String objects to respond to "each" (so they are valid "body" responses), thus the following is a valid Jack application:
	
		function(env) {
			return [200, {"Content-Type":"text/plain"}, "Hello world!"];
		}
	
	If you need something more complex with extra state, you may use an object that has an "invoke" method:
		
		MyApp = function(something) {
			this.something = something;
		}
		MyApp.prototype.invoke = function(env) {
			return [200, {"Content-Type":"text/plain"}, "Hello " + this.something + "!"];
		}
		
		new MyApp("Fred");
		
	The first (and only) argument to the invoke method is the "environment", which contains a number of properties. Many of the common CGI environment variables are included, as well as some Jack specific properties which are prefixed with "jack.".

	The Request and Response objects aren't required, but may be helpful in getting request parameters, and building a valid response. They are used as follows:
	
		var req = new Jack.Request(env);
		var name = req.GET()["name"];
		
		var resp = new Jack.Response();
		resp.setHeader("Content-Type", "text/plain");
		resp.write("hello "+name+"!");
		return resp.finish(); // equivalent to returning [200, {"Content-Type" : "text/plain"}, "hello "+name+"!"]
		
	These objects are works in progress.


== Roundabout

	Roundabout is a Rack compatible application / middleware that works like the Sinatra Ruby framework.
	
	One major difference is that Roundabout can be used as middleware to map other Rack components to specific URL patterns, like a more powerful version of the URLMap middleware.
	
	More documentation forthcoming. See the "roundup" script for examples.

	
== Writing Jack Middleware:

	Jack middleware performs some sort of pre or post processing on requests, such as logging, authentication, etc. Most Jack middleware, by convention (and required for use with the Builder DSL, etc), is a constructor that takes in one argument, "app" (which will be a Jack application) and creates a Jack application (i.e. something that responds to "invoke"). In it's "invoke" method it will typically optionally do some preprocessing, followed by calling the "app" that was provided in the constructor, optionally followed by some post processing.
	
	For example, the "Head" middleware call the "app", then checks to see if the request HTTP method was "HEAD". If so, it clears the body of response before returning it, since HEAD requests shouldn't have a response body.
	
	A more complicated middleware might need to peform postprocessing on the body contents. A common pattern is to call the app, then store the body as a property of itself and return itself *as* the body instead. It also defines an "each" method on itself that proxies to the stored body property. A good example of this is the CommonLogger middleware, which does this in order to calculate the body length for logging.


== Misc:

	Jack depends on a small library currently named "core.js" which contains a basic Ruby-style "require" method as well as some additions to the built in JavaScript objects, etc. Eventually this should be split off into a separate project for general server-side JavaScript usage.


== Differences between Jack and Rack:

  Jack uses "invoke" instead of "call" as the interface between Jack apps/middleware. This is because "call" is already defined on functions in JavaScript, and uses the first parameter as the "this" for the method call. The primary difference is that "invoke" does not use the first argument for "this"; the arguments provided to "invoke" will be exactly the arguments provided to the method body.


== Component Status:

Core:

	Request:	incomplete
	Response: incomplete
	
Utilities:

	Builder: complete?
	Jackup: unimplemented

Handlers:

	Servlet: for use with Rhino and Jetty or other servlet container. mostly complete.
	Jetty: simple wrapper using Servlet handler and Jetty Java libs (the jetty, jetty-util, servlet-api jars)
    Simple: for use with the Simple webserver
	
	FastCGI: incomplete. needs FastCGI lib

Middleware:

	CommonLogger: 	mostly complete (needs correct date formatting)
	ContentLength:	complete
	File: 					broken (needs better file IO)
	Head:						complete
	Lint: 					mostly complete (needs stream wrappers)
	ShowExceptions: simple version complete
	Static: 				complete (but broken due to File dependecy)
	URLMap: 				complete
	

== Acknowledgments

This software was influenced by Rack, written by Christian Neukirchen.

http://rack.rubyforge.org/


== License:

Copyright (c) 2009 Thomas Robinson <tlrobinson.net>

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to
deal in the Software without restriction, including without limitation the
rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER 
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

